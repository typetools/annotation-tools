\documentclass{article}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{relsize}
\usepackage{url}
\usepackage{hevea}
\usepackage[shortcuts]{extdash}
% \usepackage{verbdef}

\def\topfraction{.9}
\def\dbltopfraction{\topfraction}
\def\floatpagefraction{\topfraction}     % default .5
\def\dblfloatpagefraction{\topfraction}  % default .5
\def\textfraction{.1}

%HEVEA \footerfalse    % Disable hevea advertisement in footer

\newcommand{\code}[1]{\ifmmode{\mbox{\relax\ttfamily{#1}}}\else{\relax\ttfamily #1}\fi}
%% Hevea version omits "\smaller"
%HEVEA \renewcommand{\code}[1]{\ifmmode{\mbox{\ttfamily{#1}}}\else{\ttfamily #1}\fi}

\newcommand{\includeimage}[2]{
\begin{center}
\ifhevea\imgsrc{#1.png}\else
\resizebox{!}{#2}{\includegraphics{figures/#1}}
\vspace{-1.5\baselineskip}
\fi
\end{center}}

% Add line between figure and text
\makeatletter
\def\topfigrule{\kern3\p@ \hrule \kern -3.4\p@} % the \hrule is .4pt high
\def\botfigrule{\kern-3\p@ \hrule \kern 2.6\p@} % the \hrule is .4pt high
\def\dblfigrule{\kern3\p@ \hrule \kern -3.4\p@} % the \hrule is .4pt high
\makeatother


\title{Annotation File Format Specification}
% Hevea ignores \date, so move the date into \author
\author{\url{http://types.cs.washington.edu/annotation-file-utilities/} \\
\today}
\date{}

\begin{document}

\maketitle

%HEVEA \setcounter{tocdepth}{2}
\tableofcontents

\section{Purpose:  External storage of annotations\label{purpose}}

Java annotations are meta-data about Java program elements, as in
``\code{@Deprecated class Date \{ ... \}}''.
Ordinarily, Java annotations are written in the source code of a
\code{.java} Java source file.  When \code{javac} compiles the source code,
it inserts the annotations in the resulting \code{.class} file (as
``attributes'').

Sometimes, it is convenient to specify the annotations outside the source
code or the \code{.class} file.
\begin{itemize}
%BEGIN LATEX
\itemsep 0pt \parskip 0pt
%END LATEX
\item
  When source code is not available, a textual file provides a format for
  writing and storing annotations that is much easier to read and modify
  than a \code{.class} file.  Even if the eventual purpose is to insert the
  annotations in the \code{.class} file, the annotations must be specified
  in some textual format first.
\item
  Even when source code is available, sometimes it should not be changed,
  yet annotations must be stored somewhere for use by tools.
\item
  A textual file for annotations can eliminate code clutter.  A developer
  performing some specialized task (such as code verification,
  parallelization, etc.)\ can store annotations in an annotation file without
  changing the main version of the source code.  (The developer's private
  version of the code could contain the annotations, but the developer
  could copy them to the separate file before committing changes.)
\item
  Tool writers may find it more convenient to use a textual file, rather
  than writing a Java or \code{.class} file parser.
\item
  When debugging annotation-processing tools, a textual file format
  (extracted from the Java or \code{.class} files) is easier to read, and
  is easier for use in testing.
\end{itemize}

All of these uses require an external, textual file format for Java annotations.
The external file format should be easy for people to create, read, and
modify.
%
An ``annotation file'' serves this purpose by specifying a set of
Java annotations.
The Annotation File Utilities
(\url{http://types.cs.washington.edu/annotation-file-utilities/}) are a set
of tools that process annotation files.

The file format discussed in this document supports both standard Java SE 5
declaration annotations and also the extended annotations proposed in JSR 308~\cite{JSR308}.
Section ``Class File Format Extensions'' of the JSR 308 design document
explains how the extended annotations are stored in the \code{.class}
file.  The
annotation file closely follows the class file format.
In that sense, the current design is extremely low-level, and users
probably would not want to write the files by hand (but might fill in a
template that a tool generated automatically).  As future work, we should
design a more
user-friendly format that permits Java signatures to be directly specified.
Furthermore, since the current design is closely aligned to the class file,
it is convenient for tools that operate on \code{.class} files but less
convenient for tools that operate on \code{.java} files.



%% I don't like this, as it may force distributing logically connected
%% elements all over a file system.  Users should be permitted, but not
%% forced, to adopt such a file structure. -MDE
%   Each file corresponds to exactly one
% ``.class'' file, so (for instance) inner classes are written in
% separate annotation files, named in the same ``{\tt
% OuterClass\$InnerClass}'' pattern as the ``.class'' file.


By convention, an annotation file ends with ``\code{.jaif}'' (for ``Java
annotation index file''), but this is not required.


% \verbdef\lineend|"\n"|

%BEGIN LATEX
\DefineShortVerb{\|}
\SaveVerb{newline}|\n|
\UndefineShortVerb{\|}
\newcommand{\lineend}{\bnflit{\UseVerb{newline}}}
%END LATEX
%HEVEA \newcommand{\bs}{\char"5C}
%HEVEA \newcommand{\lineend}{\bnflit{\bs{}n}}

% literal
\newcommand{\bnflit}[1]{\textrm{``}\textbf{#1}\textrm{''}}
% non-terminal
\newcommand{\bnfnt}[1]{\textsf{\emph{#1}}}
% comment
\newcommand{\bnfcmt}{\rm \# }
% alternative
\newcommand{\bnfor}{\ensuremath{|}}


\section{Grammar\label{grammar}}

\subsection{Grammar conventions\label{grammar-conventions}}

Throughout this document, ``name'' is any valid Java simple name or 
binary name, ``type'' is any valid type, and ``value'' is any
valid Java constant, and quoted strings are literal values.
%
The Kleene qualifiers ``*'' (zero or more), ``?'' (zero or one), and ``+''
(one or more) denote plurality of a grammar element.
%
A vertical bar (``\bnfor'') separates alternatives.
Parentheses (``()'') denote grouping, and square brackets (``[]'')
denote optional syntax, which is equivalent to ``( ... ) ?'' but more concise.
We use the hash/pound/octothorpe symbol (``\#'') for comments within the grammar. 

In the annotation file,
besides its use as token separator, 
whitespace (excluding
newlines) is optional with one exception: no space is permitted
between an ``@'' character and a subsequent name. Indentation is
ignored, but is encouraged to maintain readability of the hierarchy of
program elements in the class (see the example in Section~\ref{example}).

Comments can be written throughout the annotation file using the double-slash
syntax employed by Java for single-line comments: anything following
two adjacent slashes (``//'') until the first newline is a comment.
This is omitted from the grammar for simplicity.
Block comments (``/* ... */'') are not allowed.

The line end symbol \lineend{} is used for all the different line end
conventions, that is, Windows- and Unix-style new lines are supported.



\subsection{Annotation file\label{annotation-file}}

The annotation file itself contains one or more
package definitions; each package definition describes one or more
annotations and classes in that package.

\begin{tabbing}
\qquad \= \kill
\bnfnt{annotation-file} ::= \\
\qquad    \bnfnt{package-definition}+
\end{tabbing}

The annotation file may omit certain program elements --- for instance, it
may mention only some of the packages in your program, or only some of the
classes in a package, or only some of the fields or methods of a class.
Program elements that do not appear in the annotation file are treated as
unannotated.


\subsection{Annotation uses\label{annotation-uses}}

% TODO: Are we sure about the comment for the "annotation" section below?
% Perhaps we could add that if a class is in the same package
% as an annotation it may always use the simple name (even if there's another
% annotation with the same simple name in another package)? - MP 06/28

The syntax for an annotation is the same as in a Java source file (except for
one small change noted below).

\begin{tabbing}
\qquad \= \kill
\bnfnt{annotation} ::= \\
\qquad    \bnfcmt The name may be the annotation's simple name, unless the file \\
\qquad    \bnfcmt contains definitions for two annotations with the same simple name. \\
\qquad    \bnfcmt In this case, the binary name of the annotation name is required \\
\qquad    \bnfcmt (like the fully-qualified name, but with \$ for inner classes). \\
\qquad    \bnflit{@}\bnfnt{name} [ \bnflit{(} \bnfnt{annotation-field} [ \bnflit{,} \bnfnt{annotation-field} ]+ \bnflit{)} ] \\
\\
\bnfnt{annotation-field} ::= \\
\qquad    \bnfcmt In Java, if a single-field annotation has a field named \\
\qquad    \bnfcmt ``\texttt{value}'', then that field name may be elided in uses of the\\
\qquad    \bnfcmt annotation:   ``\texttt{@A(12)}'' rather than ``\texttt{@A(value=12)}''. \\
\qquad    \bnfcmt The same convention holds in an annotation file. \\
\qquad    \bnfnt{name} \bnflit{=} \bnfnt{value}
\end{tabbing}


\subsection{Compound type annotations\label{compound-type-annotations}}

A compound type is a parameterized, wildcard, array, or nested type. A ``type
path'' is used to specify a location in a compound type for an annotation. A
type path is composed one or more pairs of type kind and type argument index.

\begin{tabbing}
\qquad \= \kill
\bnfnt{type-kind} ::= \\
\qquad    \bnflit{0} \bnfcmt annotation is deeper in this array type \\
\qquad    \bnfor{} \bnflit{1} \bnfcmt annotation is deeper in this nested type \\
\qquad    \bnfor{} \bnflit{2} \bnfcmt annotation is on the bound of this wildcard type argument \\
\qquad    \bnfor{} \bnflit{3} \bnfcmt annotation is on the i'th type argument of this parameterized type
\end{tabbing}

The type argument index must be \bnflit{0} unless the \bnfnt{type-kind} is
\bnflit{3}. In this case, the type argument index selects which type argument
of a parameterized type to use.

Type paths are explained in more detail, with many examples to ease
understanding, in Section 3.4 of the JSR 308 Specification.\footnotemark
\footnotetext{\url{http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#class-file:ext:type_path}}

\begin{tabbing}
\qquad \= \kill
\bnfnt{type-path} ::= \\
\qquad    \bnfcmt The \bnfnt{integer} is the type argument index. \\
\qquad    \bnfnt{type-kind} \bnflit{,} \bnfnt{integer} [ \bnflit{,} \bnfnt{type-kind} \bnflit{,} \bnfnt{integer} ]* \\
\\
\bnfnt{compound-type-definition} ::= \\
\qquad    \bnflit{inner-type} \bnfnt{type-path} \bnflit{:} \bnfnt{annotation}* \lineend
\end{tabbing}


\subsection{Type annotations\label{type-annotations}}

In Java SE 7, annotations can be written only on method formal parameters and
the declarations of packages, classes, methods, fields, and local variables.
These are known as ``declaration annotations''. JSR 308~\cite{JSR308} extends
Java to allow annotations on any use of a type, and on type parameter
declarations. These are known as ``type annotations'' and must be meta-annotated
with \code{ElementType.TYPE\_USE} and/or \code{ElementType.TYPE\_PARAMETER}.
These meta-annotations are described in more detail in the JSR 308
specification~\cite{JSR308}.

For locations where only declaration annotations or type annotations are
allowed the correct kind of annotation will be inserted. However, if both
declaration and type annotations are allowed at a location then the annotation
defaults to a declaration annotation. To insert a type annotation instead,
the annotation must be used in the \bnfnt{type-annotations} rule.

\begin{tabbing}
\qquad \= \kill
\bnfnt{type-annotations} ::= \\
\qquad    \bnfcmt holds the type annotations, as opposed to the declaration annotations \\
\qquad        \bnflit{type:} \bnfnt{annotation}* \lineend \\
\qquad        \bnfnt{compound-type-definition}*
\end{tabbing}


\subsection{Package definitions\label{package-definitions}}

Package definitions describe a package containing a list of annotation
definitions and classes.  A package definition also contains any
annotations on the package itself (such as those from a
\code{package-info.java} file).

\begin{tabbing}
\qquad \= \kill
\bnfnt{package-definition} ::= \\
\qquad    \bnfcmt{To specify the default package, omit the name.} \\
\qquad    \bnfcmt{Annotations on the default package are not allowed.} \\
\qquad    \bnflit{package} [ \bnfnt{name}? \bnflit{:} \bnfnt{annotation}* ] \lineend \\
\qquad    ( \bnfnt{annotation-definition} \bnfor{} \bnfnt{class-definition} ) *
\end{tabbing}


\subsection{Annotation definitions\label{annotation-definitions}}

An annotation definition describes the annotation's fields and their
types, so that they may be referenced in a compact way throughout the
annotation file.

The Annotation File Utilities can read annotation definitions from the
classpath, so it is optional to define them in the annotation file.

If an annotation is defined in the annotation file, then it must be defined
before it is used.
% either on a program element or as a field of another annotation definition.
(This requirement makes it impossible to define, in an
annotation file, an annotation that is meta-annotated with itself.)
In the annotation file, the annotation definition appears within the
package that defines the annotation.  The annotation may be applied to
elements of any package.


\begin{tabbing}
\qquad \= \kill
\bnfnt{annotation-definition} ::= \\
\qquad    \bnflit{annotation} \bnflit{@}\bnfnt{name}
    \bnflit{:} \bnfnt{annotation}* \lineend  \\ 
\qquad    \bnfnt{annotation-field-definition}* \\
\\
\bnfnt{annotation-field-definition} ::= \\
\qquad    \bnfnt{annotation-field-type} \bnfnt{name} \lineend \\
\\
\bnfnt{annotation-field-type} ::= \\
\qquad    \bnfcmt \bnfnt{primitive-type} is any Java primitive type (\texttt{int}, \texttt{boolean}, etc.). \\
\qquad    \bnfcmt These are described in detail in Section~\ref{types-and-values}. \\
\qquad    (\bnfnt{primitive-type} \bnfor{} \bnflit{String} \bnfor{} \bnflit{Class}
    \bnfor{} (\bnflit{enum} \bnfnt{name}) \bnfor{} (\bnflit{annotation-field} \bnfnt{name})) \bnflit{[]}? \\
\qquad        \bnfor{} \bnflit{unknown[]} \lineend
\end{tabbing}


\subsection{Type variable declarations\label{type-variable-declarations}}

These annotations go on the declaration of a type variable, such as on \code{K}
and \code{T} in

\begin{verbatim}
public class Class<K> {
    public <T> void m() {
        ...
    }
}
\end{verbatim}

The annotation must be a type annotation (see Section~\ref{type-annotations}).

\begin{tabbing}
\qquad \= \kill
\bnfnt{typeparam-definition} ::= \\
\qquad    \bnfcmt The integer is the zero-based type parameter index. \\
\qquad    \bnflit{typeparam} \bnfnt{integer} \bnflit{:} \bnfnt{annotation}* \lineend
\end{tabbing}


\subsection{Type variable declaration bounds\label{type-variable-declaration-bounds}}

These annotations go on a bound of a type variable declaration, such as on
\code{Number} and \code{Date} in

\begin{verbatim}
public class Class<K extends Number> {
    public <T extends Date> void () {
        ....
    }
}
\end{verbatim}

The annotation must be a type annotation (see Section~\ref{type-annotations}).

\begin{tabbing}
\qquad \= \kill
% The bound should really be a sub-element of the typeparam!
\bnfnt{bound-definition} ::= \\
\qquad    \bnfcmt The integers are respectively the parameter and bound indices of \\
\qquad    \bnfcmt the type parameter bound~\cite{JSR308}. \\
\qquad    \bnflit{bound} \bnfnt{integer} \bnflit{\&} \bnfnt{integer} \bnflit{:} \bnfnt{annotation}* \lineend \\
\qquad    \bnfnt{compound-type-definition}*
\end{tabbing}


\subsection{Class definitions\label{class-definitions}}

Class definitions describe the annotations present on the various
program elements.  It is organized according to the hierarchy of fields
and methods in the class.
Class definitions
are defined by the \code{class-definition} production of the following grammar.
Note that we use \code{class-definition} also for interfaces, enums, and
annotation types (to specify annotations in an existing annotation type, not to
be confused with \bnfnt{annotation-definitions} described in
Section~\ref{annotation-definitions}, which defines annotations to be used
throughout an annotation file); for syntactic simplicity, we use \bnflit{class}
for
all such definitions.
% TODO: add test cases for this.

Inner classes are treated as ordinary classes whose names happen to contain
\code{\$} signs and must be defined at the top level of a class definition file.
(To change this, the grammar would have to be extended with a closing
delimiter for classes; otherwise, it would be ambiguous whether a
field/method appearing after an inner class definition belonged to the
inner class or the outer class.) The syntax for inner class names is the same as
is used by the \code{javac} compiler. A good way to get an idea of the inner
class names for a class is to compile the class and look at the filenames of the
\code{.class} files that are produced.

The annotation on the \bnflit{class} line is the annotation on the class
declaration (not the class name itself) and must be a declaration annotation
(see Section~\ref{type-annotations}).

\begin{tabbing}
\qquad \= \kill
\bnfnt{class-definition} ::= \\
\qquad    \bnflit{class} \bnfnt{name} \bnflit{:} \bnfnt{annotation}* \lineend  \\
% TODO: is the order really important? eg. can fields and methods not
% be mixed?
\qquad        \bnfnt{typeparam-definition}* \\
\qquad        \bnfnt{bound-definition}* \\
\qquad        \bnfnt{extends-definition}* \\
\qquad        \bnfnt{implements-definition}* \\
\qquad        \bnfnt{field-definition}*  \\
\qquad        \bnfnt{method-definition}*
\end{tabbing}


\subsubsection{Implements and extends\label{implements-and-extends}}

Annotations can be inserted on the names of classes a class \code{implements} or
\code{extends}. Only type annotations are allowed (see
Section~\ref{type-annotations}).

\begin{tabbing}
\qquad \= \kill
\bnfnt{extends-definition} ::= \\
\qquad    \bnflit{extends} \bnflit{:} \bnfnt{annotation}* \lineend  \\
\qquad        \bnfnt{compound-type-definition}* \\
\\
\bnfnt{implements-definition} ::= \\
\qquad    \bnfcmt The integer is the zero-based index of the implemented interface. \\
\qquad    \bnflit{implements} \bnfnt{integer} \bnflit{:} \bnfnt{annotation}* \lineend  \\
\qquad        \bnfnt{compound-type-definition}*
\end{tabbing}


\subsection{Field definitions\label{field-definitons}}

For fields, an annotation on the \bnflit{field} line is that of the field
declaration and must be a declaration annotation. Annotations on type of the
field are declared within the \bnflit{type-annotations} rule and must be type
annotations (see Section~\ref{type-annotations}).

If a field is initialized at declaration then in bytecode the initialization is
actually moved to the constructor when the class is compiled. Therefore,
annotations on the initialization in bytecode go in the constructor
(see Section~\ref{method-definitions}), rather than the field definition.
However, source code insertions for field initializations are allowed and are
described in Section~\ref{code-annotations}.

\begin{tabbing}
\qquad \= \kill
\bnfnt{field-definition} ::= \\
\qquad    \bnflit{field} \bnfnt{name} \bnflit{:} \bnfnt{annotation}* \lineend  \\
\qquad        \bnfnt{type-annotations}* \\
\qquad        \bnfnt{typecast-definition}* \\
\qquad        \bnfnt{instanceof-definition}* \\
\qquad        \bnfnt{new-definition}* \\
\qquad        \bnfnt{source-insert-typecast-definition}*
\end{tabbing}


\subsection{Method definitions\label{method-definitions}}

The \bnflit{method-key} consists of the name followed by the signature in JVML
format, for example:

\begin{verbatim}
foo([ILjava/lang/String;)V
\end{verbatim}

Note that the
signature is the erased signature of the method and does not contain generic
type information, but does contain the return type. Using \code{javap -s} makes
it easy to find the signature. The method-keys ``\code{<init>}'' and
``\code{<clinit>}'' are used to name instance (constructors) and class (static)
initialization methods.

The annotation on the \bnflit{method} line is that on the method declaration,
not on the return value, and must be a declaration annotation.

\begin{tabbing}
\qquad \= \kill
\bnfnt{method-definition} ::= \\
\qquad    \bnflit{method} \bnfnt{method-key} \bnflit{:} \bnfnt{annotation}* \lineend \\
\qquad        \bnfnt{typeparam-definition}* \\
\qquad        \bnfnt{bound-definition}* \\
\qquad        \bnfnt{return-definition}? \\
\qquad        \bnfnt{receiver-definition}? \\
\qquad        \bnfnt{parameter-definition}* \\
% TODO: method throws
\qquad        \bnfnt{variable-definition}* \\
\qquad        \bnfnt{typecast-definition}* \\
\qquad        \bnfnt{instanceof-definition}* \\
\qquad        \bnfnt{new-definition}* \\
\qquad        \bnfnt{source-insert-typecast-definition}* \\
% TODO: exception types in catch clause
% TODO: .class literals
% TODO: type arguments in constructor and method calls
\\
\bnfnt{return-definition} ::=  \\
\qquad    \bnflit{return:} \bnfnt{annotation}* \lineend \\
\qquad        \bnfnt{compound-type-definition}* \\
\\
\bnfnt{receiver-definition} ::=  \\
\qquad    \bnflit{receiver:} \bnfnt{annotation}* \lineend \\
\qquad    \bnfnt{compound-type-definition}* \\
\\
\bnfnt{parameter-definition} ::= \\
\qquad    \bnfcmt The integer is the index of the formal parameter in the method \\
\qquad    \bnfcmt (i.e., 0 is the first formal parameter. The receiver parameter is not index 0. \\
\qquad    \bnfcmt Use \bnfnt{receiver-definition} to annotate the receiver parameter.) \\
\qquad    \bnfcmt The annotations on the \bnflit{parameter} line are that of the formal parameter declaration, \\
\qquad    \bnfcmt and must be declaration annotations. \\
\qquad    \bnfcmt Type annotations are declared within the \bnfnt{type-annotations} rule. \\
\qquad    \bnflit{parameter} \bnfnt{integer} \bnflit{:} \bnfnt{annotation}* \lineend \\
\qquad    \bnfnt{type-annotations}*
\end{tabbing}


\subsection{Code annotations\label{code-annotations}}

Annotations on variable declarations, typecasts, \code{instanceof}s, and
\code{new}s are supported in annotation files. However, the syntax for
specifying these annotations is different for bytecode and source code.

In order to insert annotations in both \code{.class} files and source
code, locations must be redundantly specified as bytecode offsets and source
code indexes. This can be done in a single \code{.jaif} file or two separate
\code{.jaif} files. However, since bytecode offsets and source code indexes
are not used to add annotations to signatures, it is not necessary to include
redundant information to insert annotations on signatures in both \code{.class}
files and source code.

Additionally, a typecast with annotations can be inserted into source code
(rather than an annotation added to an existing typecast). This uses a third
syntax that is described in Section~\ref{ast-paths}.


\subsubsection{Bytecode offsets\label{bytecode-offsets}}

For annotations in bytecode the
annotation file uses offsets into the bytecode array of the class file to
indicate the specific expression to which the annotation refers.  Because
different compilation strategies yield different \code{.class} files, a
tool that maps such annotations from an annotation file into source code must
have access to the specific \code{.class} file that was used to generate
the annotation file.  For non-expression annotations such as those on methods,
fields, classes, etc., the \code{.class} file is not necessary. The
\code{javap -v} command is an effective technique to figure out bytecode
offsets.


\subsubsection{Source code indexes\label{source-code-indexes}}

For annotations in source code the annotation file uses indexes to select the
correct expression. The index is a zero-based occurrence number of the
expression type in the method. For example,

\begin{verbatim}
public void method() {
    Object o1 = new @A String();
    String s = (@B String) o1;
    Object o2 = new @C Integer(0);
    Integer i = (@D Integer) o2;
}
\end{verbatim}

\code{@A} is on new, index 0. \code{@B} is on typecast, index 0. \code{@C} is on
new, index 1. \code{@D} is on typecast, index 1.

Source code indexes only include occurrences in the class that exactly matches
the name of the enclosing \bnfnt{class-definition} rule. Specifically,
occurrences in nested classes are not included. Use a new
\bnfnt{class-definition} rule with the name of the nested class for source code
insertions in a nested class.


\subsubsection{Code annotations grammar\label{code-annotations-grammar}}

For each kind of code annotation a separate location rule has been broken
out. This location rule contains the bytecode offset syntax followed by the
source code index syntax.

We use \bnflit{\#} for bytecode offsets and \bnflit{*} for source code indexes.

\begin{tabbing}
\qquad \= \kill
\bnfnt{variable-location} ::= \\
\qquad    \bnfcmt Bytecode offset: the integers are respectively the index, start, and length \\
\qquad    \bnfcmt fields of the annotations on this variable~\cite{JSR308}. \\
\qquad    (\bnfnt{integer} \bnflit{\#} \bnfnt{integer} \bnflit{+} \bnfnt{integer}) \\
\qquad    \bnfcmt Source code index: the \bnfnt{name} is the identifier of the local variable. \\
\qquad    \bnfcmt The \bnfnt{integer} is the optional zero-based index of the intended local \\
\qquad    \bnfcmt variable within all local variables with the given \bnfnt{name}. \\
\qquad    \bnfcmt The default value for the index is zero. \\
\qquad    \bnfor{} (\bnfnt{name} [\bnflit{*} \bnfnt{integer}]) \\
\\
\bnfnt{variable-definition} ::= \\
\qquad    \bnfcmt The annotations on the \bnflit{local} line are that of the variable declaration \\
\qquad    \bnfcmt and must be declaration annotations, while the annotations in the \bnfnt{type-annotations} \\
\qquad    \bnfcmt rule are that of the outermost type of the variable. \\
\qquad    \bnflit{local} \bnfnt{variable-location} \bnflit{:} \bnfnt{annotation}* \lineend \\
\qquad    \bnfnt{type-annotations}* \\
\\
\bnfnt{typecast-location} ::= \\
\qquad    \bnfcmt Bytecode offset: the first integer is the offset field and the optional \\
\qquad    \bnfcmt second integer is the type index of an intersection type~\cite{JSR308}. \\
\qquad    \bnfcmt The type index defaults to zero if not specified. \\
\qquad    (\bnflit{\#} \bnfnt{integer} [ \bnflit{,} \bnfnt{integer} ]) \\
\qquad    \bnfcmt Source code index: the first integer is the zero-based index of the typecast \\
\qquad    \bnfcmt within the method and the optional second integer is the type index of an \\
\qquad    \bnfcmt intersection type~\cite{JSR308}. The type index defaults to zero if not specified. \\
\qquad    \bnfor{} (\bnflit{*} \bnfnt{integer} [ \bnflit{,} \bnfnt{integer} ]) \\
\\
\bnfnt{typecast-definition} ::= \\
\qquad    \bnflit{typecast} \bnfnt{typecast-location} \bnflit{:} \bnfnt{annotation}* \lineend \\
\qquad    \bnfnt{compound-type-definition}* \\
\\
\bnfnt{instanceof-location} ::= \\
\qquad    \bnfcmt Bytecode offset: the integer is the offset field of the annotation~\cite{JSR308}. \\
\qquad    (\bnflit{\#} \bnfnt{integer}) \\
\qquad    \bnfcmt Source code index: the integer is the zero-based index of the instanceof within the method. \\
\qquad    \bnfor{} (\bnflit{*} \bnfnt{integer}) \\
\\
\bnfnt{instanceof-definition} ::= \\
\qquad    \bnflit{instanceof} \bnfnt{instanceof-location} \bnflit{:} \bnfnt{annotation}* \lineend \\
\qquad    \bnfnt{compound-type-definition}* \\
\\
\bnfnt{new-location} ::= \\
\qquad    \bnfcmt Bytecode offset: the integer is the offset field of the annotation~\cite{JSR308}. \\
\qquad    (\bnflit{\#} \bnfnt{integer}) \\
\qquad    \bnfcmt Source code index: the integer is the zero-based index of the object or array \\
\qquad    \bnfcmt creation within the method. \\
\qquad    \bnfor{} (\bnflit{*} \bnfnt{integer}) \\
\\
\bnfnt{new-definition} ::= \\
\qquad    \bnflit{new} \bnfnt{new-location} \bnflit{:} \bnfnt{annotation}* \lineend  \\
\qquad    \bnfnt{compound-type-definition}*
\end{tabbing}


\subsubsection{AST paths\label{ast-paths}}

Additionally, the Annotation File Utilities supports using a path through the AST (abstract
syntax tree) to specify an arbitrary expression in source code to modify.
Currently, AST paths can only be used to specify a location to insert a cast.

For a cast insertion the type to cast to must be specified in the \code{.jaif}
file. The annotations on the \bnflit{insert-typecast} line will be inserted on
the outermost type of the type to cast to. If the type to cast to is a compound
type then annotations on parts of the compound type are specified with the
\bnfnt{compound-type-definition} rule. If there are no annotations on
the \bnflit{insert-typecast} line then a cast with no annotations will be
inserted or, if compound type annotations are specified, a cast with annotations
only on the compound types will be inserted.

\begin{tabbing}
\bnfnt{source-insert-typecast-definition} ::= \\
\qquad    \bnfcmt \bnfnt{ast-path} is described below. \\
\qquad    \bnfcmt \bnfnt{type} is the un-annotated type to cast to. \\
\qquad    \bnflit{insert-typecast} \bnfnt{ast-path}\bnflit{:} \bnfnt{annotation}* \bnfnt{type} \lineend \\
\qquad        \bnfnt{compound-type-definition}*
\end{tabbing}

An AST path represents a traversal through the AST nodes. AST paths are
restricted for use in \bnfnt{field-definition}s and \bnfnt{method-definition}s.
An AST path starts with the first element under the definition type. For
methods this is \code{Block} and for fields this is \code{Variable}.

An AST path is composed of one or more AST entries, separated by commas. Each
AST entry is composed of a tree kind, a child selector, and an optional
argument. An example AST entry is:

\begin{verbatim}
Block.statement 1
\end{verbatim}

The tree kind is \code{Block}, the child selector is \code{statement} and the
argument is \code{1}.

The available tree kinds correspond to the Java AST tree nodes (from the package
\code{com.sun.source.tree}), but with ``Tree'' removed from the name. For
example, the class \code{com.sun.source.tree.BlockTree} is represented as
\code{Block}. The child selectors correspond to the method names of the given
Java AST tree node, with ``get'' removed from the beginning of the method name
and the first letter lowercased. In cases where the child selector method
returns a list, the method name is made singular and the AST entry also contains
an argument to select the index of the list to take. For example, the method
\code{com\-.sun\-.source\-.tree\-.Block\-Tree\-.get\-Statements()} is represented as
\code{Block.statement} and requires an argument to select the statement to take.

The following is an example of an entire AST path:

\begin{verbatim}
Block.statement 1, Switch.case 1, Case.statement 0, ExpressionStatement.expression,
    MethodInvocation.argument 0
\end{verbatim}

Since the above example starts with a \code{Block} it belongs in a
\bnfnt{method-definition}. This AST path would select an expression that is in
statement 1 of the method, case 1 of the switch statement, statement 0 of the
case, and argument 0 of a method call (\code{ExpressionStatement} is just a
wrapper around an expression that can also be a statement).

The following is an example of an annotation file with AST paths used to specify
where to insert casts.

\begin{verbatim}
package p:
annotation @A:

class ASTPathExample:

field a:
    insert-typecast Variable.initializer, Binary.rightOperand: @A Integer

method m()V:
    insert-typecast Block.statement 0, Variable.initializer: @A Integer
    insert-typecast Block.statement 1, Switch.case 1, Case.statement 0,
        ExpressionStatement.expression, MethodInvocation.argument 0: @A Integer
\end{verbatim}

And the matching source code:

\begin{verbatim}
package p;

public class ASTPathExample {

    private int a = 12 + 13;

    public void m() {
        int x = 1;
        switch (x + 2) {
            case 1:
                System.out.println(1);
                break;
            case 2:
                System.out.println(2 + x);
                break;
            default:
                System.out.println(-1);
        }
    }
}
\end{verbatim}

The following is the output, with the casts inserted.

\begin{verbatim}
package p;
import p.A;

public class ASTPathExample {

    private int a = 12 + ((@A Integer) (13));

    public void m() {
        int x = ((@A Integer) (1));
        switch (x + 2) {
            case 1:
                System.out.println(1);
                break;
            case 2:
                System.out.println(((@A Integer) (2 + x)));
                break;
            default:
                System.out.println(-1);
        }
    }
}
\end{verbatim}

Note that two additional sets of parentheses are always added for each cast
insertion: one set around the expression to be cast, and the other set around the
cast and the expression. For example, a cast insertion looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
((\textit{cast type}) (\textit{original expression}))
\end{Verbatim}

This is to limit the cast to the entire expression, but
nothing more. These parentheses may be unnecessary and can be removed by the
programmer afterward. Also note that a cast can be inserted on any expression, not
just the lowest expression in the AST. For example, a cast could be inserted on
the expression \code{i + j}, the identifier \code{i}, and/or the identifier \code{j}.

To help create correct AST paths it may be useful to view the AST of a class.
The Checker Framework has a processor to do this. The following command will
output indented AST nodes for the entire input program.

\begin{verbatim}
javac -processor checkers.util.debug.TreeDebug ASTPathExample.java
\end{verbatim}

The following is the grammar for AST paths.

\begin{tabbing}
\qquad \= \kill
\bnfnt{ast-path} ::= \\
\qquad    \bnfnt{ast-entry} [ \bnflit{,} \bnfnt{ast-entry} ]+ \\
\\
\bnfnt{ast-entry} ::= \\
\qquad    \bnfnt{annotated-type} \\
\qquad    \bnfor{} \bnfnt{array-access} \\
\qquad    \bnfor{} \bnfnt{array-type} \\
\qquad    \bnfor{} \bnfnt{assert} \\
\qquad    \bnfor{} \bnfnt{assignment} \\
\qquad    \bnfor{} \bnfnt{binary} \\
\qquad    \bnfor{} \bnfnt{block} \\
\qquad    \bnfor{} \bnfnt{case} \\
\qquad    \bnfor{} \bnfnt{catch} \\
\qquad    \bnfor{} \bnfnt{compound-assignment} \\
\qquad    \bnfor{} \bnfnt{conditional-expression} \\
\qquad    \bnfor{} \bnfnt{do-while-loop} \\
\qquad    \bnfor{} \bnfnt{enhanced-for-loop} \\
\qquad    \bnfor{} \bnfnt{expression-statement} \\
\qquad    \bnfor{} \bnfnt{for-loop} \\
\qquad    \bnfor{} \bnfnt{if} \\
\qquad    \bnfor{} \bnfnt{instance-of} \\
\qquad    \bnfor{} \bnfnt{labeled-statement} \\
\qquad    \bnfor{} \bnfnt{lambda-expression} \\
\qquad    \bnfor{} \bnfnt{member-reference} \\
\qquad    \bnfor{} \bnfnt{member-select} \\
\qquad    \bnfor{} \bnfnt{method-invocation} \\
\qquad    \bnfor{} \bnfnt{new-array} \\
\qquad    \bnfor{} \bnfnt{new-class} \\
\qquad    \bnfor{} \bnfnt{parameterized-type} \\
\qquad    \bnfor{} \bnfnt{parenthesized} \\
\qquad    \bnfor{} \bnfnt{return} \\
\qquad    \bnfor{} \bnfnt{switch} \\
\qquad    \bnfor{} \bnfnt{synchronized} \\
\qquad    \bnfor{} \bnfnt{throw} \\
\qquad    \bnfor{} \bnfnt{try} \\
\qquad    \bnfor{} \bnfnt{type-cast} \\
\qquad    \bnfor{} \bnfnt{unary} \\
\qquad    \bnfor{} \bnfnt{union-type} \\
\qquad    \bnfor{} \bnfnt{variable-type} \\
\qquad    \bnfor{} \bnfnt{while-loop} \\
\qquad    \bnfor{} \bnfnt{wildcard-tree} \\
\\
\bnfnt{annotated-type} :: = \\
\qquad    \bnflit{AnnotatedType} \bnflit{.} ( ( \bnflit{annotation} \bnfnt{integer} ) \bnfor{} \bnflit{underlyingType} ) \\
\\
\bnfnt{array-access} ::= \\
\qquad    \bnflit{ArrayAccess} \bnflit{.} ( \bnflit{expression} \bnfor{} \bnflit{index} ) \\
\\
\bnfnt{array-type} ::= \\
\qquad    \bnflit{ArrayType} \bnflit{.} \bnflit{type} \\
\\
\bnfnt{assert} ::= \\
\qquad    \bnflit{Assert} \bnflit{.} ( \bnflit{condition} \bnfor{} \bnflit{detail} ) \\
\\
\bnfnt{assignment} ::= \\
\qquad    \bnflit{Assignment} \bnflit{.} ( \bnflit{variable} \bnfor{} \bnflit{expression} ) \\
\\
\bnfnt{binary} ::= \\
\qquad    \bnflit{Binary} \bnflit{.} ( \bnflit{leftOperand} \bnfor{} \bnflit{rightOperand} ) \\
\\
\bnfnt{block} ::= \\
\qquad    \bnflit{Block} \bnflit{.} \bnflit{statement} \bnfnt{integer} \\
\\
\bnfnt{case} ::= \\
\qquad    \bnflit{Case} \bnflit{.} ( \bnflit{expression} \bnfor{} ( \bnflit{statement} \bnfnt{integer} ) ) \\
\\
\bnfnt{catch} ::= \\
\qquad    \bnflit{Catch} \bnflit{.} ( \bnflit{parameter} \bnfor{} \bnflit{block} ) \\
\\
\bnfnt{compound-assignment} ::= \\
\qquad    \bnflit{CompoundAssignment} \bnflit{.} ( \bnflit{variable} \bnfor{} \bnflit{expression} ) \\
\\
\bnfnt{conditional-expression} ::= \\
\qquad    \bnflit{ConditionalExpression} \bnflit{.} ( \bnflit{condition} \bnfor{} \bnflit{trueExpression} \bnfor{} \bnflit{falseExpression} ) \\
\\
\bnfnt{do-while-loop} ::= \\
\qquad    \bnflit{DoWhileLoop} \bnflit{.} ( \bnflit{condition} \bnfor{} \bnflit{statement} ) \\
\\
\bnfnt{enhanced-for-loop} ::= \\
\qquad    \bnflit{EnhancedForLoop} \bnflit{.} ( \bnflit{variable} \bnfor{} \bnflit{expression} \bnfor{} \bnflit{statement} ) \\
\\
\bnfnt{expression-statement} ::= \\
\qquad    \bnflit{ExpressionStatement} \bnflit{.} \bnflit{expression} \\
\\
\bnfnt{for-loop} ::= \\
\qquad    \bnflit{ForLoop} \bnflit{.} ( ( \bnflit{initializer} \bnfnt{integer} ) \bnfor{} \bnflit{condition} \bnfor{} ( \bnflit{update} \bnfnt{integer} )  \bnfor{} \bnflit{statement} ) \\
\\
\bnfnt{if} ::= \\
\qquad    \bnflit{If} \bnflit{.} ( \bnflit{condition} \bnfor{} \bnflit{thenStatement} \bnfor{} \bnflit{elseStatement} ) \\
\\
\bnfnt{instance-of} ::= \\
\qquad    \bnflit{InstanceOf} \bnflit{.} ( \bnflit{expression} \bnfor{} \bnflit{type} ) \\
\\
\bnfnt{labeled-statement} ::= \\
\qquad    \bnflit{LabeledStatement} \bnflit{.} \bnflit{statement} \\
\\
\bnfnt{lambda-expression} ::= \\
\qquad    \bnflit{LambdaExpression} \bnflit{.} ( ( \bnflit{parameter} \bnfnt{integer} ) \bnfor{} \bnflit{body} ) \\
\\
\bnfnt{member-reference} ::= \\
\qquad    \bnflit{MemberReference} \bnflit{.} ( \bnflit{qualifierExpression} \bnfor{} ( \bnflit{typeArgument} \bnfnt{integer} ) ) \\
\\
\bnfnt{member-select} ::= \\
\qquad    \bnflit{MemberSelect} \bnflit{.} \bnflit{expression} \\
\\
\bnfnt{method-invocation} ::= \\
\qquad    \bnflit{MethodInvocation} \bnflit{.} ( ( \bnflit{typeArgument} \bnfnt{integer} ) \bnfor{} \bnflit{methodSelect} \\
\qquad    \bnfor{} ( \bnflit{argument} \bnfnt{integer} ) ) \\
\\
\bnfnt{new-array} ::= \\
\qquad    \bnflit{NewArray} \bnflit{.} ( \bnflit{type} \bnfor{} ( \bnflit{dimension} \bnfor{} \bnflit{initializer} ) \bnfnt{integer} ) \\
\\
\bnfnt{new-class} ::= \\
\qquad    \bnflit{NewClass} \bnflit{.} ( \bnflit{enclosingExpression} \bnfor{} ( \bnflit{typeArgument} \bnfnt{integer} ) \bnfor{} \bnflit{identifier} \\
\qquad    \bnfor{} ( \bnflit{argument} \bnfnt{integer} ) \bnfor{} \bnflit{classBody} ) \\
\\
\bnfnt{parameterized-type} ::= \\
\qquad    \bnflit{ParameterizedType} \bnflit{.} ( \bnflit{type} \bnfor{} ( \bnflit{typeArgument} \bnfnt{integer} ) ) \\
\\
\bnfnt{parenthesized} ::= \\
\qquad    \bnflit{Parenthesized} \bnflit{.} \bnflit{expression} \\
\\
\bnfnt{return} ::= \\
\qquad    \bnflit{Return} \bnflit{.} \bnflit{expression} \\
\\
\bnfnt{switch} ::= \\
\qquad    \bnflit{Switch} \bnflit{.} ( \bnflit{expression} \bnfor{} ( \bnflit{case} \bnfnt{integer} ) ) \\
\\
\bnfnt{synchronized} ::= \\
\qquad    \bnflit{Synchronized} \bnflit{.} ( \bnflit{expression} \bnfor{} \bnflit{block} ) \\
\\
\bnfnt{throw} ::= \\
\qquad    \bnflit{Throw} \bnflit{.} \bnflit{expression} \\
\\
\bnfnt{try} ::= \\
\qquad    \bnflit{Try} \bnflit{.} ( \bnflit{block} \bnfor{} ( \bnflit{catch} \bnfnt{integer} ) \bnfor{} \bnflit{finallyBlock} \bnfor{} ( \bnflit{resource} \bnfnt{integer} ) ) \\
\\
\bnfnt{type-cast} ::= \\
\qquad    \bnflit{TypeCast} \bnflit{.} ( \bnflit{type} \bnfor{} \bnflit{expression} ) \\
\\
\bnfnt{unary} ::= \\
\qquad    \bnflit{Unary} \bnflit{.} \bnflit{expression} \\
\\
\bnfnt{union-type} ::= \\
\qquad    \bnflit{UnionType} \bnflit{.} \bnflit{typeAlternative} \bnfnt{integer} \\
\\
\bnfnt{variable} ::= \\
\qquad    \bnflit{Variable} \bnflit{.} ( \bnflit{type} \bnfor{} \bnflit{initializer} ) \\
\\
\bnfnt{while-loop} ::= \\
\qquad    \bnflit{WhileLoop} \bnflit{.} ( \bnflit{condition} \bnfor{} \bnflit{statement} ) \\
\\
\bnfnt{wildcard} ::= \\
\qquad    \bnflit{Wildcard} \bnflit{.} \bnflit{bound} \\
\\
\end{tabbing}

\section{Example\label{example}}

Consider the code of Figure~\ref{fig:java-example}.
Figure~\ref{fig:annotation-file-examples} shows two legal annotation files
each of which represents its annotations.


\begin{figure}
\begin{verbatim}
package p1;

import p2.*; // for the annotations @A through @D
import java.util.*;

public @A(12) class Foo {

    public int bar;             // no annotation
    private @B List<@C String> baz;

    public Foo(@D("spam") Foo this, @B List<@C String> a) {
        @B List<@C String> l = new LinkedList<@C String>();
        l = (@B List<@C String>)l;
    }
}
\end{verbatim}
\caption{Example Java code with annotations.}
\label{fig:java-example}
\end{figure}


\begin{figure}
\begin{tabular}{|c|c|}
\hline
\begin{minipage}[t]{.5\textwidth}
\begin{verbatim}
package p2:
annotation @A:
    int value
annotation @B:
annotation @C:
annotation @D:
    String value

package p1:
class Foo: @A(value=12)

    field bar:

    field baz: @B
        inner-type 0: @C

    method <init>(
      Ljava/util/List;)V:
        parameter 0: @B
            inner-type 0: @C
        receiver: @D(value="spam")
        local 1 #3+5: @B
            inner-type 0: @C
        typecast #7: @B
            inner-type 0: @C
        new #0:
            inner-type 0: @C
\end{verbatim}
\end{minipage}
&
\begin{minipage}[t]{.45\textwidth}
\begin{verbatim}
package p2:
annotation @A
    int value

package p2:
annotation @B

package p2:
annotation @C

package p2:
annotation @D
    String value

package p1:
class Foo: @A(value=12)

package p1:
class Foo:
    field baz: @B

package p1:
class Foo:
    field baz:
        inner-type 0: @C

// ... definitions for p1.Foo.<init>
// omitted for brevity
\end{verbatim}
\end{minipage}
\\
\hline
\end{tabular}

\caption{Two distinct annotation files each corresponding to the code of
  Figure~\ref{fig:java-example}.}
\label{fig:annotation-file-examples}
\end{figure}


\section{Types and values\label{types-and-values}}

The Java language permits several types for annotation fields: primitives,
\code{String}s, \code{java.lang.Class} tokens (possibly parameterized),
enumeration constants, annotations, and one-dimensional arrays of these.

These \textbf{types} are represented in an annotation file as follows:
\begin{itemize}
\item Primitive: the name of the primitive type, such as \code{boolean}.
\item String: \code{String}.
\item Class token: \code{Class}; the parameterization, if any, is not
represented in annotation files.
\item Enumeration constant: \code{enum} followed by the binary name of
the enumeration class, such as \code{enum java.lang.Thread\$State}.
\item Annotation: \code{@} followed by the binary name of the annotation type.
\item Array: The representation of the element type followed by \code{[]}, such
as \code{String[]}, with one exception: an annotation definition may specify
a field type as \code{unknown[]} if, in all occurrences of that annotation in
the annotation file, the field value is a zero-length array.\footnotemark
\footnotetext{There is a design flaw in the format of array field values in a
class file.  An array does not itself specify an element type; instead, each
element specifies its type.  If the annotation type \code{X} has an array field
\code{arr} but \code{arr} is zero-length in every \code{@X} annotation in the
class file, there is no way to determine the element type of \code{arr} from the
class file.  This exception makes it possible to define \code{X} when the class
file is converted to an annotation file.}
\end{itemize}

Annotation field \textbf{values} are represented in an annotation file as follows:
\begin{itemize}
\item Numeric primitive value: literals as they would appear in Java source
code.
\item Boolean: \code{true} or \code{false}.
\item Character: A single character or escape sequence in single quotes, such
as \code{'A'} or \code{'\char`\\''}.
\item String: A string literal as it would appear in source code, such as
\code{"\char`\\"Yields falsehood when quined\char`\\" yields falsehood when quined."}.
\item Class token: The binary name of the class (using \code{\$} for
inner classes) or the name of the primitive type or \code{void}, possibly
followed by \code{[]}s representing array layers, followed by \code{.class}.
Examples: \code{java.lang.Integer[].class}, \code{java.util.Map\$Entry.class},
and \code{int.class}.
\item Enumeration constant: the name of the enumeration constant, such as
\code{RUNNABLE}.
\item Array: a sequence of elements inside \code{\char`\{\char`\}} with a comma
between each pair of adjacent elements; a comma following the last element is
optional as in Java.  Also as in Java, the braces may be omitted if the
array has only one element.
Examples: \code{\char`\{1\char`\}}, \code{1},
\code{\char`\{true, false,\char`\}} and \code{\char`\{\char`\}}.
\end{itemize}

The following example annotation file shows how types and values are represented.

\begin{verbatim}
package p1:

annotation @ClassInfo:
    String remark
    Class favoriteClass
    Class favoriteCollection // it's probably Class<? extends Collection>
                             // in source, but no parameterization here
    char favoriteLetter
    boolean isBuggy
    enum p1.DebugCategory[] defaultDebugCategories
    @p1.CommitInfo lastCommit

annotation @CommitInfo:
    byte[] hashCode
    int unixTime
    String author
    String message

class Foo: @p1.ClassInfo(
    remark="Anything named \"Foo\" is bound to be good!",
    favoriteClass=java.lang.reflect.Proxy.class,
    favoriteCollection=java.util.LinkedHashSet.class,
    favoriteLetter='F',
    isBuggy=true,
    defaultDebugCategories={DEBUG_TRAVERSAL, DEBUG_STORES, DEBUG_IO},
    lastCommit=@p1.CommitInfo(
        hashCode={31, 41, 59, 26, 53, 58, 97, 92, 32, 38, 46, 26, 43, 38, 32, 79},
        unixTime=1152109350,
        author="Joe Programmer",
        message="First implementation of Foo"
    )
)
\end{verbatim}


\section{Alternative formats\label{alternative-formats}}

We mention two alternatives to the format described in this document.
Each of them has its own merits.
In the future, the other formats could be implemented, along with tools for
converting among them.
% Then, we can see which of the formats programmers prefer in practice.



An alternative to the format described in this document would be XML\@.  
% It would be easy to use an XML format to augment the one proposed here, but
XML does not seem to provide any compelling advantages.  Programmers
interact with annotation files in two ways:  textually (when reading, writing,
and editing annotation files) and programmatically (when writing
annotation-processing tools).  Textually, XML can be
very hard to read; style sheets mitigate this
problem, but editing XML files remains tedious and error-prone.
Programmatically, a layer of abstraction (an API) is needed in any event, so it
makes little difference what the underlying textual representation is.
XML files are easier to parse, but the parsing code only needs to be
written once and is abstracted away by an API to the data structure.


Another alternative is a format like the \code{.spec}/\code{.jml} files
of JML~\cite{LeavensBR2006:JML}.  The format is similar to Java code, but
all method bodies are empty, and users can annotate the public members of a
class.  This is easy for Java programmers to read and understand.  (It is a
bit more complex to implement, but that is not particularly germane.)
Because it does not permit complete specification of a class's annotations
(it does not permit annotation of method bodies), it is not appropriate for
certain tools, such as type inference tools.  However, it might be desirable
to adopt such a format for public members, and to use the format
described in this document primarily for method bodies.


\section{Design and Implementation Details\label{design-and-implementation-details}}

This section describes some high level design and implementation details of the
Annotation Files Utilities', including the different components of the
Annotation File Utilities and how they fit together. It is intended for someone
who is beginning work on the Annotation File Utilities or is curious about how
the Annotation File Utilities work.

This section will not provided line-by-line descriptions of the code, but it
does link back to specific files and methods with the intention that the reader
will follow along in the code while reading this section.

The Annotation File Utilities is composed of three sub-projects:
\code{scene-lib}, \code{asmx}, and \code{annotation\-/file\-/utilities}. The
\code{scene-lib} sub-project is a representation of a \code{.jaif} file. The
\code{asmx} sub-project does the insertion and extraction of annotations to and
from bytecode. The \code{annotation-file-utilities} sub-project does the
insertion of annotations into source code.

\subsection{\code{scene-lib}\label{scene-lib}}

\code{scene-lib} is an interface to a \code{.jaif} file. It reads in and writes
out \code{.jaif} files and provides an internal representation of a \code{.jaif}
file to access and manipulate.

\begin{figure}
\includeimage{scene-lib-type-hierarchy}{5cm}
\caption{The type hierarchy of the \code{scene-lib} classes used to represent a
  \code{.jaif} file.}
\label{fig:scene-lib-type-hierarchy}
\end{figure}

Internally, a \code{.jaif} file is represented by the
scene-lib/src/annotations/el/AScene.java class. The \code{AScene} class (or
``annotated scene'') roughly parallels the root of an abstract syntax tree. An
\code{AScene} has a number of classes (\code{AClass}) as children. Each class
has a number of methods (\code{AMethod}), fields (\code{AElement}), etc. as
children. All of these classes are related in a type hierarchy. This type
hierarchy is shown in Figure~\ref{fig:scene-lib-type-hierarchy}. Note that this
type hierarchy does not have a traditional ``is-a'' relationship between its
classes. For example, it is not valid to say that a method is-a block, as the
type hierarchy implies. In fact, it makes more sense to view the type hierarchy
upside down, like so: a method contains a block, a block contains multiple
expressions, and an expression contains an element. (Perhaps object composition
would have been a better pattern to follow here.)

Each class in the type hierarchy has one or more fields to hold annotations for
the different components of the class. For example, the \code{AMethod} class has
the following fields: bounds, return type, receiver parameters, and throws
clause. Each of these fields holds the annotations stored on that part of the
method. For details on the remainder of the classes in the type hierarchy, and
their respective fields, see the documentation for each file in
scene-lib/src/annotations/el/.

An \code{AScene} instance can be created in two ways. An empty \code{AScene} can
be created by calling the \code{AScene} constructor or an \code{AScene} can be
created by parsing an existing \code{.jaif} file. Once an \code{AScene} is
created annotations can be added to it by adding them to the correct fields of
the children. An \code{AScene} can also be output to create a new \code{.jaif}
file.

\subsection{\code{asmx}\label{asmx}}

The \code{asmx} sub-project is used to insert and extract annotations from
bytecode. \code{asmx} is based off of an old version (2.2.2) of the ASM
Framework~\cite{ASM}. It has been modified to allow it to read and write
JSR 308~\cite{JSR308} annotations in bytecode. However, it is far behind the
current ASM version (4.1). Experimental support for type annotations has been
added to ASM for a future ASM 5 release. The goal is to replace the custom
\code{asmx} in the Annotation File Utilities with the official, supported
version of ASM.

\subsubsection{Bytecode Insertion\label{bytecode-insertion}}

Annotations can be inserted into bytecode by executing the
annotation-file-utilities/scripts/insert-annotations script. This script takes
one or more class name and \code{.jaif} file pairs as arguments. The annotations
specified in the \code{.jaif} file are inserted into the classfile directly
before the \code{.jaif} file in the argument list.

First, the \code{.jaif} files is parsed into an \code{AScene} (as described in
Section~\ref{scene-lib}). Then,
asmx/\-src/\-org/\-objectweb/\-asm/\-Class\-Read\-er.java parses the classfile.
As it is parsing the classfile, it passes the parsed bytecode off to the
scene-lib/src/annotations/io/classfile/ClassAnnotationSceneWriter.java
class. This class has a reference to the \code{AScene} parsed from the
\code{.jaif} file. As this class receives the parsed bytecode it inserts the
annotations from the \code{AScene} in the correct place in the bytecode and then
writes the bytecode back out.

\subsubsection{Bytecode Extraction\label{bytecode-extraction}}

Annotations can be extracted from bytecode by executing the
annotation-file-utilities/scripts/\-extract-anno\-tations script. This script
takes one or more class names as arguments and outputs the annotations found in
those classes to \code{.jaif} files.

First, an empty \code{AScene} is constructed to store the annotations.
asmx/\-src/\-org/\-objectweb/\-asm/\-Class\-Read\-er.java parses the classfile
and passes the parsed bytecode off to the
scene-lib/\-src/\-annotations/\-io/\-classfile/\-Class\-Annotation\-Scene\-Reader.java
class. This class filters out the annotations in the bytecode and adds them to
the correct part of the \code{AScene}. After this, the \code{AScene} is output
to a \code{.jaif} file.

\subsection{\code{annotation-file-utilities}\label{annotation-file-utilities}}

The \code{annotation-file-utilities} sub-project inserts annotations into source
code. It can be run by executing the
annotation-file-utilities/scripts/insert-annotations-to-source script.
The script takes one or more \code{.jaif} files, followed by one or more
\code{.java} source files as arguments. The annotations in the \code{.jaif}
files are inserted into the \code{.java} source files.

First, an instance of
annotation-file-utilities/src/annotator/specification/IndexFileSpecification.java
is created. The \code{parse} method is called, which parses the \code{.jaif}
file into an \code{AScene} (as described in Section~\ref{scene-lib}). After
this, the \code{parse} method then calls the \code{parseScene} method, which
traverses through the \code{AScene} and creates an
annotation-file-utilities/src/annotator/specification/CriterionList.java.
The \code{CriterionList} class contains objects that implement the
annotation-file-utilities/src/annotator/find/Criterion.java interface.
The various \code{Criterion} classes are in the
annotation-file-utilities/src/annotator/find/ directory. Each \code{Criterion}
implementation has an \code{isSatisifiedBy} method. This method takes a location
in the abstract syntax tree and returns \code{true} if meets the
\code{Criterion} and \code{false} otherwise. For example, take the following
source code:

\begin{verbatim}
package afu.example;

public class Test {
    public void m(boolean b, int i) {
      // ...
    }
}
\end{verbatim}

The \code{Criterion}s needed for the location of the \code{i} parameter are:

\begin{itemize}
  \item \code{InPackageCriterion("afu.example")}
  \item \code{InClassCriterion("Test")}
  \item \code{InMethodCriterion("m(ZI)V")}
  \item \code{ParamCriterion(1)}
\end{itemize}

After this \code{CriterionList} is built up an
annotation-file-utilities/src/annotator/find/Insertion.java is created.
An \code{Insertion} stores an
annotation-file-utilities/src/annotator/find/Criteria.java (which is created
from a \code{CriterionList}) and the text to be inserted. All of these
\code{Insertion}s are then added to a list. The Java compiler then is called to
parse the Java source into an abstract syntax tree. This is followed by a call
to the \code{getPositions} method of
annotation-file-utilities/src/annotator/find/TreeFinder.java, which scans
through each node of the abstract syntax trees. For each node, it runs through
the \code{Criteria} for each un-matched \code{Insertion}. If at least one of the
\code{Criteria} does not match, then this is not the correct place for the
\code{Insertion} and the \code{Insertion} will be checked at the remaining nodes
of the tree. If all of the \code{Criteria} match, then this node is the correct
place for the \code{Insertion}. It is removed from the list of un-matched
\code{Insertion}s and the position where to insert the \code{Insertion} is
determined. This position is the integer index in the file where the
\code{Insertion} should be inserted. After the positions are found for all of
the \code{Insertion}s, the \code{Insertion} text is inserted into the file. This
happens backwards, with \code{Insertion}s at the end of the file (i.e. with
higher positions) being inserted first. If \code{Insertion}s were instead
inserted from the beginning of the file then a single \code{Insertion} would
invalidate all of the positions for the following \code{Insertion}s.

If there are remaining \code{Insertion}s that were not matched to a node in the
abstract syntax tree then an error message is displayed.



\bibliographystyle{alpha}
\bibliography{bibstring-unabbrev,types,ernst,invariants,generals,alias}

\end{document}

% LocalWords:  java javac OuterClass InnerClass TODO Kleene MP subannotations
% LocalWords:  enum arr quined int pt instanceof RUNTIME JVML ILjava boolean
% LocalWords:  programmatically jml ernst jaif whitespace
